# 总结
节点角色类型：leader、candidate、follower，
leader 会周期性的向集群内其他节点发送心跳，每一轮周期都会检查自身角色是否还是不是leader，以及自身的任期是否有效。
follower会周期性的检查自身的角色状态是否发生变化、任期是否有效、心跳是否过期。
candidate会发起选主流程，同时保持follower的职责。

### 如何保证一个任期内只有一个leader？
在选举机制上，一个 term 内，一个 follower 只有一票，因此只能投票给一个 candidate；最后，基于多数派原则，一个 candidate 只有拿到半数以上的赞同票才能当选 leader. 因此，同一个 term 内，不可能出现有两个 candidate 同时获得半数以上的赞同票，因此一个 term 至多只有一个 leader.
在代码实现上为了保证自己只能投一票，在处理投票请求的时候是加了锁的，自己的投票结果是绝对无法更改的。
### 节点之间并发选举 导致 永远选不出个leader？
节点之间依靠比较term来判断谁可以当leader，每一个节点都会从follower角色调整为 candidate 视图让自己成为leader， candidate 竞选前会自增 term, 然后和其他节点通信来比较term谁大， 谁大谁就可以拿到票。 在初始情况下每一个节点的任期都是0，然后都标记自身为candidate，任期就都为1， 然后每个节点都去其他节点要票， 然后发现任期一样，其他节点的票又都投给了自己， 反复这么拉扯 导致永远选不出leader。
这个概率比较小，需要所有的节点同时发起投票，然后才有可能出现这个结果，解决方案可以随机生成心跳超时时间，这样就必然存在时间差，比如自己的心跳超时时间比较短，发现10ms内没收到leader的心跳，尝试发起选举， 然后别的节点因为超时时间设的比较大，还没尝试发起选举， 那么这个时候就不会出现这个情况了。

### 任期变化限制
任期只会在以下两种情况发生变化：
- 节点收到了拉票请求时，只要拉票请求中的任期大于自身，那么节点就会用拉票请求中的任期来更新自身的任期，以结束上一任期的心跳检测，同时再继续以follower角色进入下一个任期的心跳检测。  
- 节点以follower角色执行心跳检测时，发现异常，进而成为candidate，提升自身任期。
那么可能就会出现 任期不断提升，但leader 还未选出来，比如5个节点的raft 集群,leader 挂掉时，其他4个节点同时标记自己是candidate 任期都从1变成2，发起拉票，因为每个节点都直接给自己投票了。 导致任期为2 时没有选出leader。
然后每个节点继续因为 心跳检测超时，继续提升任期2变成3，再因为这个反复拉扯，导致任期不断上升，但每一个任期都不存在leader。，

### 时间尺度
