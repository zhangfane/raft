### 总结
由leader接收写请求，leader先在本地追加预写日志，然后再集群内部发起提案投票广播，申请应用到状态机，倘若集群总计半数以上的节点（包括 leader 自身）都将这笔请求添加预写日志，并给予了 leader 肯定的答复（ack），那么 leader 此时会“提交”这个请求，并给予客户端写请求已成功处理的响应。其他节点在随后的时段中，会通过与 leader 的交互（心跳或其他同步数据的请求）感知到这个“提交”动作，最终也在预写日志中提交这笔请求；
预写日志必定包含2个关键字段：term、index，分别表示该条日志在哪个任期接收以及在整个预写日志中的位置。
### 二阶段提交2pc
leader 收到客户端的请求写入数据时，需要将写操作日志发送给raft集群其他follower节点， 如果leader收到过半数的节点的同意响应，那么意味着该操作日志是可以提交的， 此时再一次发起提交请求，收到过半数提交同意，那么这个客户端的请求才算是真正处理完了。 这种leader先发起提案申请（预写日志）拿到半数同一票后，leader再发起提案提交并拿到半数同意票后的操作 就称为2pc。

为什么要有二阶段提交？为了集群内部达成共识，leader写数据必须要通知到集群内大多数节点都知道需要写入数据了，在拿到过半数的同意，就相当于过半数的节点都有了相同的预写日志，这就能够保障数据必定可以成功提交了。 客户端虽然是只和leader交互发起读请求，但本质上是和整个集群交互，写数据，数据是否成功写入，就必定要先让leader去发起提案，然后提交。
### 如何保证集群内每个节点的预写日志内容和顺序完全一致？
日志的term和index可以认为是该条预写日志的唯一索引，因此，在 term 相同的情况下，所有节点在同一个 index 上的日志都会与 term 内 leader 对应 index 位置的日志保持一致； 而follower在收到leader的预写日志提案时，也校验上一条预写日志是否和leader一致，那么就可以保证每一个节点的预写日志内容及其顺序都和leader完全一致。

### 任期内未完成的事情
如果发生leader切换，为什么新leader一定有前leader提交的日志？由选举机制和二阶段提交保证的，只有被集群多数派完成同步的日志才会被 leader 提交，在选举流程中，节点只会把票投给日志进度不滞后于自身的 candidate；这就保障了新的leader一定有集群内的最新日志。 
leader的心跳广播会包含：自身的任期、已提交进度、已提案进度, follower会在心跳请求里回复自身的 进度。 

无论是老leader 是在2阶段的的什么阶段挂掉的。 如果
在提案阶段挂掉，